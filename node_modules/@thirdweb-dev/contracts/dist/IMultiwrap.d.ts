import { BigNumberish, BigNumber, utils, BytesLike, BaseContract, Signer, CallOverrides, Overrides, ContractTransaction, PayableOverrides, PopulatedTransaction } from 'ethers';
import { FunctionFragment, Result, EventFragment } from '@ethersproject/abi';
import { Provider, Listener } from '@ethersproject/providers';
import { TypedEvent, TypedEventFilter, TypedListener, OnEvent } from './common';

declare namespace MultiTokenTransferLib {
    type MultiTokenStruct = {
        erc1155AssetContracts: string[];
        erc1155TokensToWrap: BigNumberish[][];
        erc1155AmountsToWrap: BigNumberish[][];
        erc721AssetContracts: string[];
        erc721TokensToWrap: BigNumberish[][];
        erc20AssetContracts: string[];
        erc20AmountsToWrap: BigNumberish[];
    };
    type MultiTokenStructOutput = [
        string[],
        BigNumber[][],
        BigNumber[][],
        string[],
        BigNumber[][],
        string[],
        BigNumber[]
    ] & {
        erc1155AssetContracts: string[];
        erc1155TokensToWrap: BigNumber[][];
        erc1155AmountsToWrap: BigNumber[][];
        erc721AssetContracts: string[];
        erc721TokensToWrap: BigNumber[][];
        erc20AssetContracts: string[];
        erc20AmountsToWrap: BigNumber[];
    };
}
interface IMultiwrapInterface extends utils.Interface {
    contractName: string | "IMultiwrap";
    functions: {
        "contractType()": FunctionFragment;
        "contractURI()": FunctionFragment;
        "contractVersion()": FunctionFragment;
        "getDefaultRoyaltyInfo()": FunctionFragment;
        "getRoyaltyInfoForToken(uint256)": FunctionFragment;
        "owner()": FunctionFragment;
        "royaltyInfo(uint256,uint256)": FunctionFragment;
        "setContractURI(string)": FunctionFragment;
        "setDefaultRoyaltyInfo(address,uint256)": FunctionFragment;
        "setOwner(address)": FunctionFragment;
        "setRoyaltyInfoForToken(uint256,address,uint256)": FunctionFragment;
        "supportsInterface(bytes4)": FunctionFragment;
        "unwrap(uint256,uint256,address)": FunctionFragment;
        "wrap((address[],uint256[][],uint256[][],address[],uint256[][],address[],uint256[]),uint256,string)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "contractType", values?: undefined): string;
    encodeFunctionData(functionFragment: "contractURI", values?: undefined): string;
    encodeFunctionData(functionFragment: "contractVersion", values?: undefined): string;
    encodeFunctionData(functionFragment: "getDefaultRoyaltyInfo", values?: undefined): string;
    encodeFunctionData(functionFragment: "getRoyaltyInfoForToken", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "owner", values?: undefined): string;
    encodeFunctionData(functionFragment: "royaltyInfo", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "setContractURI", values: [string]): string;
    encodeFunctionData(functionFragment: "setDefaultRoyaltyInfo", values: [string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "setOwner", values: [string]): string;
    encodeFunctionData(functionFragment: "setRoyaltyInfoForToken", values: [BigNumberish, string, BigNumberish]): string;
    encodeFunctionData(functionFragment: "supportsInterface", values: [BytesLike]): string;
    encodeFunctionData(functionFragment: "unwrap", values: [BigNumberish, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: "wrap", values: [MultiTokenTransferLib.MultiTokenStruct, BigNumberish, string]): string;
    decodeFunctionResult(functionFragment: "contractType", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "contractURI", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "contractVersion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getDefaultRoyaltyInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getRoyaltyInfoForToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "owner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "royaltyInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setContractURI", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setDefaultRoyaltyInfo", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setOwner", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setRoyaltyInfoForToken", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "supportsInterface", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "unwrap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "wrap", data: BytesLike): Result;
    events: {
        "DefaultRoyalty(address,uint256)": EventFragment;
        "OwnerUpdated(address,address)": EventFragment;
        "RoyaltyForToken(uint256,address,uint256)": EventFragment;
        "TokensUnwrapped(address,address,uint256,uint256,tuple)": EventFragment;
        "TokensWrapped(address,uint256,tuple)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "DefaultRoyalty"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "OwnerUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RoyaltyForToken"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokensUnwrapped"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "TokensWrapped"): EventFragment;
}
declare type DefaultRoyaltyEvent = TypedEvent<[
    string,
    BigNumber
], {
    newRoyaltyRecipient: string;
    newRoyaltyBps: BigNumber;
}>;
declare type DefaultRoyaltyEventFilter = TypedEventFilter<DefaultRoyaltyEvent>;
declare type OwnerUpdatedEvent = TypedEvent<[
    string,
    string
], {
    prevOwner: string;
    newOwner: string;
}>;
declare type OwnerUpdatedEventFilter = TypedEventFilter<OwnerUpdatedEvent>;
declare type RoyaltyForTokenEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber
], {
    tokenId: BigNumber;
    royaltyRecipient: string;
    royaltyBps: BigNumber;
}>;
declare type RoyaltyForTokenEventFilter = TypedEventFilter<RoyaltyForTokenEvent>;
declare type TokensUnwrappedEvent = TypedEvent<[
    string,
    string,
    BigNumber,
    BigNumber,
    MultiTokenTransferLib.MultiTokenStructOutput
], {
    wrapper: string;
    sentTo: string;
    tokenIdOfShares: BigNumber;
    sharesUnwrapped: BigNumber;
    wrappedContents: MultiTokenTransferLib.MultiTokenStructOutput;
}>;
declare type TokensUnwrappedEventFilter = TypedEventFilter<TokensUnwrappedEvent>;
declare type TokensWrappedEvent = TypedEvent<[
    string,
    BigNumber,
    MultiTokenTransferLib.MultiTokenStructOutput
], {
    wrapper: string;
    tokenIdOfShares: BigNumber;
    wrappedContents: MultiTokenTransferLib.MultiTokenStructOutput;
}>;
declare type TokensWrappedEventFilter = TypedEventFilter<TokensWrappedEvent>;
interface IMultiwrap extends BaseContract {
    contractName: string | "IMultiwrap";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: IMultiwrapInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        contractType(overrides?: CallOverrides): Promise<[string]>;
        contractURI(overrides?: CallOverrides): Promise<[string]>;
        contractVersion(overrides?: CallOverrides): Promise<[number]>;
        getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<[string, number]>;
        getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string, number]>;
        owner(overrides?: CallOverrides): Promise<[string]>;
        royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<[
            string,
            BigNumber
        ] & {
            receiver: string;
            royaltyAmount: BigNumber;
        }>;
        setContractURI(_uri: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setOwner(_newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<[boolean]>;
        unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    contractType(overrides?: CallOverrides): Promise<string>;
    contractURI(overrides?: CallOverrides): Promise<string>;
    contractVersion(overrides?: CallOverrides): Promise<number>;
    getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<[string, number]>;
    getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string, number]>;
    owner(overrides?: CallOverrides): Promise<string>;
    royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<[
        string,
        BigNumber
    ] & {
        receiver: string;
        royaltyAmount: BigNumber;
    }>;
    setContractURI(_uri: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setOwner(_newOwner: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;
    unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: PayableOverrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        contractType(overrides?: CallOverrides): Promise<string>;
        contractURI(overrides?: CallOverrides): Promise<string>;
        contractVersion(overrides?: CallOverrides): Promise<number>;
        getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<[string, number]>;
        getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<[string, number]>;
        owner(overrides?: CallOverrides): Promise<string>;
        royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<[
            string,
            BigNumber
        ] & {
            receiver: string;
            royaltyAmount: BigNumber;
        }>;
        setContractURI(_uri: string, overrides?: CallOverrides): Promise<void>;
        setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: CallOverrides): Promise<void>;
        setOwner(_newOwner: string, overrides?: CallOverrides): Promise<void>;
        setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: CallOverrides): Promise<void>;
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<boolean>;
        unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: CallOverrides): Promise<void>;
        wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: CallOverrides): Promise<BigNumber>;
    };
    filters: {
        "DefaultRoyalty(address,uint256)"(newRoyaltyRecipient?: null, newRoyaltyBps?: null): DefaultRoyaltyEventFilter;
        DefaultRoyalty(newRoyaltyRecipient?: null, newRoyaltyBps?: null): DefaultRoyaltyEventFilter;
        "OwnerUpdated(address,address)"(prevOwner?: null, newOwner?: null): OwnerUpdatedEventFilter;
        OwnerUpdated(prevOwner?: null, newOwner?: null): OwnerUpdatedEventFilter;
        "RoyaltyForToken(uint256,address,uint256)"(tokenId?: BigNumberish | null, royaltyRecipient?: null, royaltyBps?: null): RoyaltyForTokenEventFilter;
        RoyaltyForToken(tokenId?: BigNumberish | null, royaltyRecipient?: null, royaltyBps?: null): RoyaltyForTokenEventFilter;
        "TokensUnwrapped(address,address,uint256,uint256,tuple)"(wrapper?: string | null, sentTo?: null, tokenIdOfShares?: BigNumberish | null, sharesUnwrapped?: null, wrappedContents?: null): TokensUnwrappedEventFilter;
        TokensUnwrapped(wrapper?: string | null, sentTo?: null, tokenIdOfShares?: BigNumberish | null, sharesUnwrapped?: null, wrappedContents?: null): TokensUnwrappedEventFilter;
        "TokensWrapped(address,uint256,tuple)"(wrapper?: string | null, tokenIdOfShares?: BigNumberish | null, wrappedContents?: null): TokensWrappedEventFilter;
        TokensWrapped(wrapper?: string | null, tokenIdOfShares?: BigNumberish | null, wrappedContents?: null): TokensWrappedEventFilter;
    };
    estimateGas: {
        contractType(overrides?: CallOverrides): Promise<BigNumber>;
        contractURI(overrides?: CallOverrides): Promise<BigNumber>;
        contractVersion(overrides?: CallOverrides): Promise<BigNumber>;
        getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<BigNumber>;
        getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        owner(overrides?: CallOverrides): Promise<BigNumber>;
        royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        setContractURI(_uri: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setOwner(_newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<BigNumber>;
        unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        contractType(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        contractURI(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        contractVersion(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getDefaultRoyaltyInfo(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getRoyaltyInfoForToken(tokenId: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        owner(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        royaltyInfo(tokenId: BigNumberish, salePrice: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setContractURI(_uri: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setDefaultRoyaltyInfo(_royaltyRecipient: string, _royaltyBps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setOwner(_newOwner: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setRoyaltyInfoForToken(tokenId: BigNumberish, recipient: string, bps: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        supportsInterface(interfaceId: BytesLike, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        unwrap(tokenId: BigNumberish, amountToRedeem: BigNumberish, _sendTo: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        wrap(wrappedContents: MultiTokenTransferLib.MultiTokenStruct, shares: BigNumberish, uriForShares: string, overrides?: PayableOverrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}

export { DefaultRoyaltyEvent, DefaultRoyaltyEventFilter, IMultiwrap, IMultiwrapInterface, MultiTokenTransferLib, OwnerUpdatedEvent, OwnerUpdatedEventFilter, RoyaltyForTokenEvent, RoyaltyForTokenEventFilter, TokensUnwrappedEvent, TokensUnwrappedEventFilter, TokensWrappedEvent, TokensWrappedEventFilter };
