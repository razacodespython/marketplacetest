'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');
var providers = require('@ethersproject/providers');
var wagmiCore = require('wagmi-core');
var ethers = require('ethers');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__namespace = /*#__PURE__*/_interopNamespace(React);

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var useProvider = () => {
  var {
    state
  } = useContext();
  return state.provider;
};

var useWebSocketProvider = () => {
  var {
    state
  } = useContext();
  return state.webSocketProvider;
};

var useCacheBuster = () => {
  var context = useContext();
  return context.state.cacheBuster;
};

var useCancel = () => {
  var cancelCallback = React__namespace.useRef(null);
  React__namespace.useEffect(() => {
    return () => {
      var _cancelCallback$curre;

      return (_cancelCallback$curre = cancelCallback.current) === null || _cancelCallback$curre === void 0 ? void 0 : _cancelCallback$curre.call(cancelCallback);
    };
  }, []);
  var cancel = React__namespace.useCallback(callback => {
    var _cancelCallback$curre2;

    (_cancelCallback$curre2 = cancelCallback.current) === null || _cancelCallback$curre2 === void 0 ? void 0 : _cancelCallback$curre2.call(cancelCallback);
    if (callback) cancelCallback.current = callback;
  }, []);
  return cancel;
};

var useLocalStorage = function useLocalStorage(key) {
  var defaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var [value, setValue] = React__namespace.useState(() => {
    if (typeof localStorage === 'undefined') return defaultState;
    var value = localStorage.getItem(key);

    try {
      return value ? JSON.parse(value) : defaultState;
    } catch (error) {
      console.warn(error);
      return defaultState;
    }
  });
  var setLocalStorage = React__namespace.useCallback(newValue => {
    if (newValue === value) return;
    setValue(newValue);
    if (newValue === null) localStorage.removeItem(key);else localStorage.setItem(key, JSON.stringify(newValue));

    if (newValue === null) {
      localStorage.removeItem(key);
    } else {
      try {
        localStorage.setItem(key, JSON.stringify(newValue));
      } catch (error) {
        console.error(error);
      }
    }
  }, [value, setValue, key]);
  return [value, setLocalStorage];
};

var initialState$f = {
  loading: false
};
var useEnsAvatar = function useEnsAvatar() {
  var {
    addressOrName,
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var [state, setState] = React__namespace.useState(initialState$f);
  var cancelQuery = useCancel();
  var getEnsAvatar = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var config_ = config !== null && config !== void 0 ? config : {
          addressOrName
        };
        if (!config_.addressOrName) throw new Error('addressOrName is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var avatar = yield provider.getAvatar(config_.addressOrName);

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            avatar,
            loading: false
          }));
        }

        return avatar;
      } catch (error_) {
        var error = error_;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return error;
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [addressOrName, cancelQuery, provider]); // Fetch avatar when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip || !addressOrName) return;
    getEnsAvatar({
      addressOrName
    });
    return cancelQuery;
  }, [addressOrName, cacheBuster, cancelQuery, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.avatar,
    loading: state.loading,
    error: state.error
  }, getEnsAvatar];
};

var initialState$e = {
  loading: false
};
var useEnsLookup = function useEnsLookup() {
  var {
    address,
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var [state, setState] = React__namespace.useState(initialState$e);
  var cancelQuery = useCancel();
  var lookupAddress = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var config_ = config !== null && config !== void 0 ? config : {
          address
        };
        if (!config_.address) throw new Error('address is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var ens = yield provider.lookupAddress(config_.address);

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            ens,
            loading: false
          }));
        }

        return {
          data: ens,
          error: undefined
        };
      } catch (error_) {
        var error = error_;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [address, cancelQuery, provider]); // Resolve name when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip || !address) return;
    lookupAddress({
      address
    });
    return cancelQuery;
  }, [address, cacheBuster, cancelQuery, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.ens,
    loading: state.loading,
    error: state.error
  }, lookupAddress];
};

var initialState$d = {
  loading: false
};
var useEnsResolveName = function useEnsResolveName() {
  var {
    name,
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var [state, setState] = React__namespace.useState(initialState$d);
  var cancelQuery = useCancel();
  var resolveName = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var config_ = config !== null && config !== void 0 ? config : {
          name
        };
        if (!config_.name) throw new Error('name is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var address = yield provider.resolveName(config_.name);

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            address,
            loading: false
          }));
        }

        return {
          data: address,
          error: undefined
        };
      } catch (error_) {
        var error = error_;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [name, cancelQuery, provider]); // Resolve name when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip || !name) return;
    resolveName({
      name
    });
    return cancelQuery;
  }, [name, cacheBuster, cancelQuery, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.address,
    loading: state.loading,
    error: state.error
  }, resolveName];
};

var initialState$c = {
  loading: false
};
var useEnsResolver = function useEnsResolver() {
  var {
    name,
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var [state, setState] = React__namespace.useState(initialState$c);
  var cancelQuery = useCancel();
  var getEnsResolver = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var config_ = config !== null && config !== void 0 ? config : {
          name
        };
        if (!config_.name) throw new Error('name is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var resolver = yield provider.getResolver(config_.name);

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            loading: false,
            resolver
          }));
        }

        return {
          data: resolver,
          error: undefined
        };
      } catch (error_) {
        var error = error_;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [cancelQuery, name, provider]); // Fetch avatar when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip || !name) return;
    getEnsResolver({
      name
    });
    return cancelQuery;
  }, [cacheBuster, cancelQuery, name, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.resolver,
    loading: state.loading,
    error: state.error
  }, getEnsResolver];
};

var useAccount = function useAccount() {
  var _globalState$data;

  var {
    fetchEns
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: globalState,
    setState
  } = useContext();
  var address = (_globalState$data = globalState.data) === null || _globalState$data === void 0 ? void 0 : _globalState$data.account;
  var [{
    data: ens,
    error: ensError,
    loading: ensLoading
  }] = useEnsLookup({
    address,
    skip: !fetchEns
  });
  var [{
    data: avatar,
    error: avatarError,
    loading: avatarLoading
  }] = useEnsAvatar({
    addressOrName: ens,
    skip: !fetchEns || !ens
  });
  var disconnect = React__namespace.useCallback(() => {
    setState(x => {
      var _x$connector;

      (_x$connector = x.connector) === null || _x$connector === void 0 ? void 0 : _x$connector.disconnect();
      return {
        cacheBuster: x.cacheBuster + 1
      };
    });
  }, [setState]);
  var error = ensError || avatarError;
  var loading = ensLoading || avatarLoading;
  return [{
    data: address ? {
      address,
      connector: globalState.connector,
      ens: ens ? {
        avatar,
        name: ens
      } : undefined
    } : undefined,
    error,
    loading
  }, disconnect];
};

var initialState$b = {
  loading: false
};
var useBlockNumber = function useBlockNumber() {
  var {
    skip,
    watch
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var webSocketProvider = useWebSocketProvider();
  var [state, setState] = React__namespace.useState(initialState$b);
  var cancelQuery = useCancel();
  var getBlockNumber = React__namespace.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {
    var didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });

    try {
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        error: undefined,
        loading: true
      }));
      var blockNumber = yield provider.getBlockNumber();

      if (!didCancel) {
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          blockNumber,
          loading: false
        }));
      }

      return {
        data: blockNumber,
        error: undefined
      };
    } catch (error_) {
      var error = error_;

      if (!didCancel) {
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
      }

      return {
        data: undefined,
        error
      };
    }
  }), [cancelQuery, provider]);
  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip) return;
    getBlockNumber();
    return cancelQuery;
  }, [cacheBuster, cancelQuery, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (!watch) return;
    var didCancel = false;

    var listener = blockNumber => {
      // Just to be safe in case the provider implementation
      // calls the event callback after .off() has been called
      if (!didCancel) {
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          blockNumber
        }));
      }
    };

    var provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;
    provider_.on('block', listener);
    return () => {
      didCancel = true;
      provider_.off('block', listener);
    };
  }, [provider, watch, webSocketProvider]);
  return [{
    data: state.blockNumber,
    error: state.error,
    loading: state.loading
  }, getBlockNumber];
};

var initialState$a = {
  loading: false
};
var useFeeData = function useFeeData() {
  var {
    formatUnits = 'wei',
    skip,
    watch
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var provider = useProvider();
  var [{
    data: blockNumber
  }] = useBlockNumber({
    skip: true,
    watch
  });
  var cacheBuster = useCacheBuster();
  var [state, setState] = React__namespace.useState(initialState$a);
  var cancelQuery = useCancel();
  var getFeeData = React__namespace.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {
    var didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });

    try {
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        error: undefined,
        loading: true
      }));
      var feeData = yield provider.getFeeData();

      if (!didCancel) {
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          feeData,
          loading: false
        }));
      }

      return {
        data: feeData,
        error: undefined
      };
    } catch (error_) {
      var error = error_;

      if (!didCancel) {
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
      }

      return {
        data: undefined,
        error
      };
    }
  }), [cancelQuery, provider]); // Fetch feeData on mount or when chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip) return;
    getFeeData();
    return cancelQuery;
  }, [cacheBuster, cancelQuery, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (!watch || !blockNumber) return;
    getFeeData();
    return cancelQuery;
  }, [blockNumber, cancelQuery, getFeeData, watch]);
  var formatted = state.feeData ? {
    gasPrice: ethers.utils.formatUnits(state.feeData.gasPrice, formatUnits),
    maxFeePerGas: ethers.utils.formatUnits(state.feeData.maxFeePerGas, formatUnits),
    maxPriorityFeePerGas: ethers.utils.formatUnits(state.feeData.maxPriorityFeePerGas, formatUnits)
  } : undefined;
  return [{
    data: state.feeData ? _objectSpread2(_objectSpread2({}, state.feeData), {}, {
      formatted
    }) : undefined,
    loading: state.loading,
    error: state.error
  }, getFeeData];
};

var initialState$9 = {
  loading: false
};
var useBalance = function useBalance() {
  var {
    addressOrName,
    formatUnits = 'ether',
    skip,
    token,
    watch
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var [{
    data: blockNumber
  }] = useBlockNumber({
    skip: true,
    watch
  });
  var [state, setState] = React__namespace.useState(initialState$9);
  var cancelQuery = useCancel();
  var getBalance = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var _connector$chains;

        var config_ = config !== null && config !== void 0 ? config : {
          addressOrName,
          formatUnits,
          token
        };
        if (!config_.addressOrName) throw new Error('address is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var balance = yield wagmiCore.balanceAction({
          chains: [...((_connector$chains = connector === null || connector === void 0 ? void 0 : connector.chains) !== null && _connector$chains !== void 0 ? _connector$chains : []), ...wagmiCore.defaultChains, ...wagmiCore.defaultL2Chains],
          config: config_,
          provider
        });
        if (!didCancel) setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          balance,
          loading: false
        }));
        return {
          data: balance,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        if (!didCancel) setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [addressOrName, cancelQuery, connector, formatUnits, provider, token]); // Fetch balance when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip || !addressOrName) return;
    getBalance({
      addressOrName,
      formatUnits,
      token
    });
    return cancelQuery;
  }, [addressOrName, cacheBuster, cancelQuery, skip, token]);
  /* eslint-enable react-hooks/exhaustive-deps */

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (!watch) return;
    if (!blockNumber) return;
    if (!addressOrName) return;
    getBalance({
      addressOrName,
      formatUnits,
      token
    });
  }, [blockNumber]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.balance,
    error: state.error,
    loading: state.loading
  }, getBalance];
};

var initialState$8 = {
  loading: false
};
var useConnect = () => {
  var _globalState$data;

  var {
    state: globalState,
    setState: setGlobalState,
    setLastUsedConnector
  } = useContext();
  var [state, setState] = React__namespace.useState(initialState$8);
  var cancelQuery = useCancel();
  var connect = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (connector) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var activeConnector = globalState === null || globalState === void 0 ? void 0 : globalState.connector;
        if (connector === activeConnector) throw new wagmiCore.ConnectorAlreadyConnectedError();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: true,
          connector,
          error: undefined
        }));
        var data = yield connector.connect();

        if (!didCancel) {
          // Update connector globally only after successful connection
          setGlobalState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            connector,
            data
          }));
          setLastUsedConnector(connector.name);
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            loading: false
          }));
        }

        return {
          data,
          error: undefined
        };
      } catch (error_) {
        var error = error_;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            connector: undefined,
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [cancelQuery, globalState.connector, setGlobalState, setLastUsedConnector]); // Keep connector in sync with global connector

  React__namespace.useEffect(() => {
    setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
      connector: globalState.connector,
      error: undefined
    }));
    return cancelQuery;
  }, [cancelQuery, globalState.connector]);
  return [{
    data: {
      connected: !!((_globalState$data = globalState.data) !== null && _globalState$data !== void 0 && _globalState$data.account),
      connector: state.connector,
      connectors: globalState.connectors
    },
    error: state.error,
    loading: state.loading || globalState.connecting
  }, connect];
};

var initialState$7 = {
  loading: false
};
var useNetwork = () => {
  var _data$chain, _data$chain2, _connector$chains;

  var {
    state: {
      connector,
      data
    }
  } = useContext();
  var [state, setState] = React__namespace.useState(initialState$7);
  var chainId = data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id;
  var unsupported = data === null || data === void 0 ? void 0 : (_data$chain2 = data.chain) === null || _data$chain2 === void 0 ? void 0 : _data$chain2.unsupported;
  var activeChains = (_connector$chains = connector === null || connector === void 0 ? void 0 : connector.chains) !== null && _connector$chains !== void 0 ? _connector$chains : [];
  var activeChain = [...activeChains, ...wagmiCore.allChains].find(x => x.id === chainId);
  var cancelQuery = useCancel();
  var switchNetwork = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (chainId) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });
      if (!(connector !== null && connector !== void 0 && connector.switchChain)) return {
        data: undefined,
        error: new wagmiCore.SwitchChainError()
      };

      try {
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var chain = yield connector.switchChain(chainId);

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            loading: false
          }));
        }

        return {
          data: chain,
          error: undefined
        };
      } catch (error_) {
        var error = error_;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [cancelQuery, connector]);
  return [{
    data: {
      chain: chainId ? _objectSpread2(_objectSpread2({}, activeChain), {}, {
        id: chainId,
        unsupported
      }) : undefined,
      chains: activeChains
    },
    error: state.error,
    loading: state.loading
  }, connector !== null && connector !== void 0 && connector.switchChain ? switchNetwork : undefined];
};

var initialState$6 = {
  data: undefined,
  error: undefined,
  loading: false
};
var useSigner = function useSigner() {
  var {
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var {
    state: {
      connector
    }
  } = useContext();
  var [state, setState] = React__namespace.useState(initialState$6);
  var cancelQuery = useCancel();
  var getSigner = React__namespace.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {
    var didCancel = false;
    cancelQuery(() => {
      didCancel = true;
    });

    try {
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        error: undefined,
        loading: true
      }));
      var signer = yield connector === null || connector === void 0 ? void 0 : connector.getSigner();

      if (!didCancel) {
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          data: signer,
          loading: false
        }));
      }

      return signer;
    } catch (error_) {
      var error = error_;

      if (!didCancel) {
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          data: undefined,
          error,
          loading: false
        }));
      }
    }
  }), [cancelQuery, connector]);
  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip) return;
    getSigner();
    return cancelQuery;
  }, [cacheBuster, connector, cancelQuery, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [state, getSigner];
};

var initialState$5 = {
  loading: false
};
var useSignMessage = function useSignMessage() {
  var {
    message
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var [state, setState] = React__namespace.useState(initialState$5);
  var cancelQuery = useCancel();
  var signMessage = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var config_ = config !== null && config !== void 0 ? config : {
          message
        };
        if (!config_.message) throw new Error('message is required');
        if (!connector) throw new wagmiCore.ConnectorNotFoundError();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var signer = yield connector.getSigner();
        var signature = yield signer.signMessage(config_.message);

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            signature,
            loading: false
          }));
        }

        return {
          data: signature,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        if (error_.code === 4001) error = new wagmiCore.UserRejectedRequestError();

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [cancelQuery, connector, message]);
  return [{
    data: state.signature,
    error: state.error,
    loading: state.loading
  }, signMessage];
};

var getContract = _ref => {
  var {
    addressOrName,
    contractInterface,
    signerOrProvider
  } = _ref;
  return new ethers.Contract(addressOrName, contractInterface, signerOrProvider);
};

var useContract = _ref2 => {
  var {
    addressOrName,
    contractInterface,
    signerOrProvider
  } = _ref2;
  return React__namespace.useMemo(() => {
    return getContract({
      addressOrName,
      contractInterface,
      signerOrProvider
    });
  }, [addressOrName, contractInterface, signerOrProvider]);
};

var useContractEvent = function useContractEvent(contractConfig, eventName, listener) {
  var {
    once
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var provider = useProvider();
  var webSocketProvider = useWebSocketProvider();
  var contract = useContract(_objectSpread2({
    signerOrProvider: webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider
  }, contractConfig));
  var listenerRef = React__namespace.useRef(listener);
  listenerRef.current = listener;
  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    var handler = function handler() {
      for (var _len = arguments.length, event = new Array(_len), _key = 0; _key < _len; _key++) {
        event[_key] = arguments[_key];
      }

      return listenerRef.current(event);
    };

    var contract_ = contract;
    if (once) contract_.once(eventName, handler);else contract_.on(eventName, handler);
    return () => {
      contract_.off(eventName, handler);
    };
  }, [contract, eventName]);
  /* eslint-enable react-hooks/exhaustive-deps */
};

var initialState$4 = {
  loading: false
};
var useContractRead = function useContractRead(contractConfig, functionName) {
  var {
    args,
    overrides,
    skip,
    watch
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var contract = useContract(_objectSpread2({
    signerOrProvider: provider
  }, contractConfig));
  var [{
    data: blockNumber
  }] = useBlockNumber({
    skip: true,
    watch
  });
  var [state, setState] = React__namespace.useState(initialState$4);
  var cancelQuery = useCancel();
  var read = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var config_ = config !== null && config !== void 0 ? config : {
          args,
          overrides
        };
        var params = [...(Array.isArray(config_.args) ? config_.args : config_.args ? [config_.args] : []), ...(config_.overrides ? [config_.overrides] : [])];
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true,
          response: undefined
        }));
        var response = yield contract[functionName](...params);

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            loading: false,
            response
          }));
        }

        return {
          data: response,
          error: undefined
        };
      } catch (error_) {
        var error = error_;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [args, cancelQuery, contract, functionName, overrides]);
  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip) return;
    read();
    return cancelQuery;
  }, [cacheBuster, cancelQuery, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (!watch) return;
    if (!blockNumber) return;
    read();
    return cancelQuery;
  }, [blockNumber, cancelQuery, watch]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.response,
    error: state.error,
    loading: state.loading
  }, read];
};

var initialState$3 = {
  loading: false
};
var useContractWrite = function useContractWrite(contractConfig, functionName) {
  var {
    args,
    overrides
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var contract = useContract(contractConfig);
  var [state, setState] = React__namespace.useState(initialState$3);
  var cancelQuery = useCancel();
  var write = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var config_ = config !== null && config !== void 0 ? config : {
          args,
          overrides
        };
        if (!connector) throw new wagmiCore.ConnectorNotFoundError();
        var params = [...(Array.isArray(config_.args) ? config_.args : config_.args ? [config_.args] : []), ...(config_.overrides ? [config_.overrides] : [])];
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true,
          response: undefined
        }));
        var signer = yield connector.getSigner();
        var contract_ = contract.connect(signer);
        var response = yield contract_[functionName](...params);

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            loading: false,
            response
          }));
        }

        return {
          data: response,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        if (error_.code === 4001) error = new wagmiCore.UserRejectedRequestError();

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [args, cancelQuery, connector, contract, functionName, overrides]);
  return [{
    data: state.response,
    error: state.error,
    loading: state.loading
  }, write];
};

var initialState$2 = {
  loading: false
};
var useToken = function useToken() {
  var {
    address,
    formatUnits = 'ether',
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var provider = useProvider();
  var [state, setState] = React__namespace.useState(initialState$2);
  var cancelQuery = useCancel();
  var getToken = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var _config_$formatUnits;

        var config_ = config !== null && config !== void 0 ? config : {
          address,
          formatUnits
        };
        if (!config_.address) throw new Error('address is required');
        var contract = new ethers.ethers.Contract(config_.address, wagmiCore.erc20ABI, provider);
        var formatUnits_ = (_config_$formatUnits = config_.formatUnits) !== null && _config_$formatUnits !== void 0 ? _config_$formatUnits : 'ether';
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var [symbol, decimals, totalSupply] = yield Promise.all([contract.symbol(), contract.decimals(), contract.totalSupply()]);
        var token = {
          address: config_.address,
          decimals,
          symbol,
          totalSupply: {
            formatted: ethers.utils.formatUnits(totalSupply, formatUnits_),
            value: totalSupply
          }
        };

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            token,
            loading: false
          }));
        }

        return {
          data: token,
          error: undefined
        };
      } catch (error_) {
        var error = error_;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [address, cancelQuery, formatUnits, provider]);
  var watchToken = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (token) {
      if (!(connector !== null && connector !== void 0 && connector.watchAsset)) return false;

      try {
        yield connector.watchAsset(token);
        return true;
      } catch (error) {
        return error;
      }
    });

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }(), [connector]);
  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip || !address) return;
    getToken({
      address,
      formatUnits
    });
    return cancelQuery;
  }, [address, cancelQuery, formatUnits, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.token ? _objectSpread2(_objectSpread2({}, state.token), {}, {
      address
    }) : undefined,
    error: state.error,
    loading: state.loading
  }, watchToken, getToken];
};

var initialState$1 = {
  loading: false
};
var useTransaction = function useTransaction() {
  var {
    request
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var [state, setState] = React__namespace.useState(initialState$1);
  var cancelQuery = useCancel();
  var sendTransaction = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var config_ = config !== null && config !== void 0 ? config : {
          request
        };
        if (!config_.request) throw new Error('request is required');
        if (!connector) throw new wagmiCore.ConnectorNotFoundError();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: true
        }));
        var signer = yield connector.getSigner();
        var transaction = yield signer.sendTransaction(config_.request);

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            loading: false,
            transaction
          }));
        }

        return {
          data: transaction,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        if (error_.code === 4001) error = new wagmiCore.UserRejectedRequestError();

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [cancelQuery, connector, request]);
  return [{
    data: state.transaction,
    error: state.error,
    loading: state.loading
  }, sendTransaction];
};

var initialState = {
  loading: false
};
var useWaitForTransaction = function useWaitForTransaction() {
  var {
    confirmations,
    hash,
    skip,
    timeout,
    wait: wait_
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var provider = useProvider();
  var [state, setState] = React__namespace.useState(initialState);
  var cancelQuery = useCancel();
  var wait = React__namespace.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      var didCancel = false;
      cancelQuery(() => {
        didCancel = true;
      });

      try {
        var config_ = config !== null && config !== void 0 ? config : {
          confirmations,
          hash,
          timeout,
          wait: wait_
        };
        if (!config_.hash && !config_.wait) throw new Error('hash or wait is required');
        var promise; // eslint-disable-next-line testing-library/await-async-utils

        if (config_.wait) promise = config_.wait(config_.confirmations);else if (config_.hash) promise = provider.waitForTransaction(config_.hash, config_.confirmations, config_.timeout);else throw new Error('hash or wait is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: true
        }));
        var receipt = yield promise;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            loading: false,
            receipt
          }));
        }

        return {
          data: receipt,
          error: undefined
        };
      } catch (error_) {
        var error = error_;

        if (!didCancel) {
          setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
            error,
            loading: false
          }));
        }

        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [cancelQuery, confirmations, hash, provider, timeout, wait_]); // Fetch balance when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (skip || !hash && !wait_) return;
    /* eslint-disable testing-library/await-async-utils */

    wait({
      confirmations,
      hash,
      timeout,
      wait: wait_
    });
    /* eslint-enable testing-library/await-async-utils */

    return cancelQuery;
  }, [cancelQuery, hash, skip, wait_]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.receipt,
    error: state.error,
    loading: state.loading
  }, wait];
};

var Context = /*#__PURE__*/React__namespace.createContext(null);
var Provider = _ref => {
  var _state$data2, _state$data2$chain, _state$data4, _state$data4$chain, _state$data6, _state$data6$chain;

  var {
    autoConnect = false,
    children,
    connectors: connectors_ = [new wagmiCore.InjectedConnector()],
    connectorStorageKey = 'wagmi.wallet',
    provider: provider_ = providers.getDefaultProvider(),
    webSocketProvider: webSocketProvider_
  } = _ref;
  var [lastUsedConnector, setLastUsedConnector] = useLocalStorage(connectorStorageKey);
  var [state, setState] = React__namespace.useState({
    cacheBuster: 1,
    connecting: autoConnect
  });
  var connectors = React__namespace.useMemo(() => {
    var _state$data, _state$data$chain;

    if (typeof connectors_ !== 'function') return connectors_;
    return connectors_({
      chainId: (_state$data = state.data) === null || _state$data === void 0 ? void 0 : (_state$data$chain = _state$data.chain) === null || _state$data$chain === void 0 ? void 0 : _state$data$chain.id
    });
  }, [connectors_, (_state$data2 = state.data) === null || _state$data2 === void 0 ? void 0 : (_state$data2$chain = _state$data2.chain) === null || _state$data2$chain === void 0 ? void 0 : _state$data2$chain.id]);
  var provider = React__namespace.useMemo(() => {
    var _state$data3, _state$data3$chain;

    if (typeof provider_ !== 'function') return provider_;
    return provider_({
      chainId: (_state$data3 = state.data) === null || _state$data3 === void 0 ? void 0 : (_state$data3$chain = _state$data3.chain) === null || _state$data3$chain === void 0 ? void 0 : _state$data3$chain.id,
      connector: state.connector
    });
  }, [provider_, (_state$data4 = state.data) === null || _state$data4 === void 0 ? void 0 : (_state$data4$chain = _state$data4.chain) === null || _state$data4$chain === void 0 ? void 0 : _state$data4$chain.id, state.connector]);
  var webSocketProvider = React__namespace.useMemo(() => {
    var _state$data5, _state$data5$chain;

    if (!webSocketProvider_) return undefined;
    if (typeof webSocketProvider_ !== 'function') return webSocketProvider_;
    return webSocketProvider_({
      chainId: (_state$data5 = state.data) === null || _state$data5 === void 0 ? void 0 : (_state$data5$chain = _state$data5.chain) === null || _state$data5$chain === void 0 ? void 0 : _state$data5$chain.id,
      connector: state.connector
    });
  }, [webSocketProvider_, (_state$data6 = state.data) === null || _state$data6 === void 0 ? void 0 : (_state$data6$chain = _state$data6.chain) === null || _state$data6$chain === void 0 ? void 0 : _state$data6$chain.id, state.connector]); // Attempt to connect on mount

  /* eslint-disable react-hooks/exhaustive-deps */

  React__namespace.useEffect(() => {
    if (!autoConnect) return;

    _asyncToGenerator(function* () {
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        connecting: true
      }));
      var sorted = lastUsedConnector ? [...connectors].sort(x => x.name === lastUsedConnector ? -1 : 1) : connectors;

      var _loop = function* _loop(connector) {
        if (!connector.ready || !connector.isAuthorized) return "continue";
        var isAuthorized = yield connector.isAuthorized();
        if (!isAuthorized) return "continue";
        var data = yield connector.connect();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          connector,
          data
        }));
        return "break";
      };

      for (var connector of sorted) {
        var _ret = yield* _loop(connector);

        if (_ret === "continue") continue;
        if (_ret === "break") break;
      }

      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        connecting: false
      }));
    })();
  }, []);
  /* eslint-enable react-hooks/exhaustive-deps */
  // Make sure connectors close

  React__namespace.useEffect(() => {
    return () => {
      if (!state.connector) return;
      state.connector.disconnect();
    };
  }, [state.connector]); // Watch connector for events

  React__namespace.useEffect(() => {
    if (!state.connector) return;

    var onChange = data => setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
      cacheBuster: x.cacheBuster + 1,
      data: _objectSpread2(_objectSpread2({}, x.data), data)
    }));

    var onDisconnect = () => setState({
      cacheBuster: 1
    });

    var onError = error => setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
      error
    }));

    state.connector.on('change', onChange);
    state.connector.on('disconnect', onDisconnect);
    state.connector.on('error', onError);
    return () => {
      if (!state.connector) return;
      state.connector.off('change', onChange);
      state.connector.off('disconnect', onDisconnect);
      state.connector.off('error', onError);
    };
  }, [state.connector]);
  var value = {
    state: {
      cacheBuster: state.cacheBuster,
      connecting: state.connecting,
      connectors,
      connector: state.connector,
      data: state.data,
      provider,
      webSocketProvider
    },
    setState,
    setLastUsedConnector
  };
  return /*#__PURE__*/React__namespace.createElement(Context.Provider, {
    value
  }, children);
};
var useContext = () => {
  var context = React__namespace.useContext(Context);
  if (!context) throw Error('Must be used within Provider');
  return context;
};

Object.defineProperty(exports, 'AddChainError', {
  enumerable: true,
  get: function () { return wagmiCore.AddChainError; }
});
Object.defineProperty(exports, 'ChainNotConfiguredError', {
  enumerable: true,
  get: function () { return wagmiCore.ChainNotConfiguredError; }
});
Object.defineProperty(exports, 'Connector', {
  enumerable: true,
  get: function () { return wagmiCore.Connector; }
});
Object.defineProperty(exports, 'ConnectorAlreadyConnectedError', {
  enumerable: true,
  get: function () { return wagmiCore.ConnectorAlreadyConnectedError; }
});
Object.defineProperty(exports, 'ConnectorNotFoundError', {
  enumerable: true,
  get: function () { return wagmiCore.ConnectorNotFoundError; }
});
Object.defineProperty(exports, 'InjectedConnector', {
  enumerable: true,
  get: function () { return wagmiCore.InjectedConnector; }
});
Object.defineProperty(exports, 'SwitchChainError', {
  enumerable: true,
  get: function () { return wagmiCore.SwitchChainError; }
});
Object.defineProperty(exports, 'UserRejectedRequestError', {
  enumerable: true,
  get: function () { return wagmiCore.UserRejectedRequestError; }
});
Object.defineProperty(exports, 'allChains', {
  enumerable: true,
  get: function () { return wagmiCore.allChains; }
});
Object.defineProperty(exports, 'chain', {
  enumerable: true,
  get: function () { return wagmiCore.chain; }
});
Object.defineProperty(exports, 'defaultChains', {
  enumerable: true,
  get: function () { return wagmiCore.defaultChains; }
});
Object.defineProperty(exports, 'defaultL2Chains', {
  enumerable: true,
  get: function () { return wagmiCore.defaultL2Chains; }
});
Object.defineProperty(exports, 'developmentChains', {
  enumerable: true,
  get: function () { return wagmiCore.developmentChains; }
});
Object.defineProperty(exports, 'erc1155ABI', {
  enumerable: true,
  get: function () { return wagmiCore.erc1155ABI; }
});
Object.defineProperty(exports, 'erc20ABI', {
  enumerable: true,
  get: function () { return wagmiCore.erc20ABI; }
});
Object.defineProperty(exports, 'erc721ABI', {
  enumerable: true,
  get: function () { return wagmiCore.erc721ABI; }
});
Object.defineProperty(exports, 'normalizeChainId', {
  enumerable: true,
  get: function () { return wagmiCore.normalizeChainId; }
});
exports.Context = Context;
exports.Provider = Provider;
exports.WagmiProvider = Provider;
exports.useAccount = useAccount;
exports.useBalance = useBalance;
exports.useBlockNumber = useBlockNumber;
exports.useConnect = useConnect;
exports.useContext = useContext;
exports.useContract = useContract;
exports.useContractEvent = useContractEvent;
exports.useContractRead = useContractRead;
exports.useContractWrite = useContractWrite;
exports.useEnsAvatar = useEnsAvatar;
exports.useEnsLookup = useEnsLookup;
exports.useEnsResolveName = useEnsResolveName;
exports.useEnsResolver = useEnsResolver;
exports.useFeeData = useFeeData;
exports.useNetwork = useNetwork;
exports.useProvider = useProvider;
exports.useSignMessage = useSignMessage;
exports.useSigner = useSigner;
exports.useToken = useToken;
exports.useTransaction = useTransaction;
exports.useWaitForTransaction = useWaitForTransaction;
exports.useWebSocketProvider = useWebSocketProvider;
